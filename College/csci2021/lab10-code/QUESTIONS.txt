                           __________________

                            LAB 10 QUESTIONS
                           __________________


- Name: (FILL THIS in)
- NetID: (THE kauf0095 IN kauf0095@umn.edu)

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete the
lab.


PROBLEM 1: colmins_main.c
=========================

(A) Timing
~~~~~~~~~~

  Compile and run the provided `colmins_main' program as indicated
  below.

  ,----
  | > make
  | gcc -Wall -g -Og -c colmins_main.c		
  | gcc -Wall -g -Og -c colmins_funcs.c		
  | gcc -Wall -g -Og -c matvec_util.c
  | gcc -Wall -g -Og -o colmins_main colmins_main.o colmins_funcs.o matvec_util.o
  | 
  | > ./colmins_main 8000 16000
  `----

  Notice that the size of the matrix being used is quite large: 8000
  rows by 16000 columns. You may time other sizes but 8000x16000 is
  usually large enough to get beyond obvious cache effects on most
  machines.

  Run the program several times to ensure that you get a good sense of
  what it's normal behavior is like: there should be timing differences
  between the different functions reported on.

  Paste the timing results produced below for `./colmins_main 8000
  16000'

gnana005@csel-kh4250-08:/home/gnana005/csci2021/lab10-code $ ./colmins_main 8000 16000
     col_mins1 CPU usage: 1.4755e+00 sec
     col_mins2 CPU usage: 1.4936e+00 sec
     col_mins3 CPU usage: 1.5010e+00 sec
     col_mins4 CPU usage: 4.8432e-01 sec
     col_mins5 CPU usage: 1.1274e-01 sec


(B) Tricks
~~~~~~~~~~

  Examine the source code for `colmins_main.c'.  Identify the technique
  that is used to avoid a large amount of repeated code to time the
  multiple functions.

the code saves the result of the first so it can compare it to the others.

  if(i==0){
      mins_a = mins_b;   // save result of first to compare to others
  }


Problem 2: Comparisons in colmins_funcs.c
=========================================

(A) col_mins1 baseline
~~~~~~~~~~~~~~~~~~~~~~

  Examine the `col_mins1' function in `colmins_funcs.c' and describe the
  basic approach it uses to solve the problem of finding the minimum of
  each column of a matrix.
  - What pattern of access is used? Is this advantageous for the layout
    of the matrix?
    
The pattern of acces is that it goes through the columns first and then it goes through the rows.
This is not advantageous because it is going through the matrix's columns first, which would result in
a slower runtime. 

  - What local variables are used versus main memory gets/sets?
The local variables used are the matrix columns and rows and lengths andthen the vector lengths. 
The main memory get sets used are the MSET MGET VSET VGET.


(B) col_mins2 Comparison
~~~~~~~~~~~~~~~~~~~~~~~~

  Examine the differences between `col_mins1' and `col_mins2'.
  Particularly comment on
  - Any differences in memory access pattern
  - Any differences in use of local variables/main memory
  - Any differences in speed

Instead of accessing main memory directly every time it makes a comparison, it sets them to variables. 
min is MGET(mat,0,j) and x is MGET(mat,i,j) which is the next element in the list, and these get stored in 
memory and then accessed when there is a comparison being done like:
if(x < min){min = x;} This takes very slightly less time than the first col_mins so there isn't that much
difference between which one is used.

(C) col_mins3 Comparison
~~~~~~~~~~~~~~~~~~~~~~~~

  `col_mins3' implements an optimization called loop unrolling.  In this
  technique, rather than iterate by single increments, larger steps are
  taken. Since each iteration uses multiple local variables to store
  partial results that must eventually be combined. All this is meant to
  allow the processor to execute more instructions in sequence before
  looping back which may enable more efficient pipelined and superscalar
  operations.

  Examine the differences between `col_mins2' and `col_mins3'.
  Particularly comment on
  - Any differences in memory access pattern
  - Any differences in use of local variables/main memory
  - Any differences in speed that might be due to the new optimizations

col_mins3 uses a lot of variables to set to each of the elements in the row. 
It does this in sets of four and then it loops through those 4 variables to see which one is a minimum and 
stores that one, then it goes through the next four and so on, saving the minimum each time it foes through the 
for loop. In the end there is a clean up loop in case the number of elements is not a multiple of four then we would have missed 
some elements and so to make sure that one is checked, it will go through the rows and make sure we didn't miss one.
This one isn't that much faster than the other ones. 


(D) col_mins4 Comparison
~~~~~~~~~~~~~~~~~~~~~~~~

  `col_mins4' also loop unrolling but in a different way than
  `col_mins3'.

  Examine the differences between `col_mins3' and `col_mins4'.
  Particularly comment on
  - What loops are "unrolled" in each and how does this affect the
    remaining code?
  - Any differences in memory access pattern
  - Any differences in use of local variables/main memory
  - Any differences in speed that might be due to the new optimizations

In this one, instead of setting the min at the very end, it sets the min as it goes. It doesnt
consolidate the min of the locals, it sets four different mins each time. The speed in this one is 
relaively quicker than the speed in the other ones. 


(E) col_mins5 Comparison: The Real Lesson
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  `col_mins5' is inherently different than all of the other routines.
  Examine its structure carefully and ensure that you understand it as
  it may prove useful in an assignment.  Particularly comment on
  - Any differences in memory access pattern from the others
  - Any differences in use of local variables/main memory

This is the shortest one and also the fastest one. This one took the VSET fully out and 
put it in a different for loop. It then uses the second two for loops to iterate through the 
rows first and then the columns, and then doing the comparisons, this cuts down the time significantly.

  - Any differences in speed that might be due to the new optimizations
